// ==UserScript==
// @name         叔叔不约自动配对助手(京津冀)
// @namespace    wwbnq
// @version      2.9
// @description  针对Greasemonkey优化的自动配对助手
// @author       WWBNQ
// @match        https://www.shushubuyue.net/*
// @match        https://www.shushubuyue.com/*
// @match        http://www.shushubuyue.net/*
// @match        http://www.shushubuyue.com/*
// @grant        GM.setValue
// @grant        GM.getValue
// @grant        window.close
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    const CONFIG = {
        CHECK_INTERVAL: 500 + Math.random() * 200,  // 500-700ms
        MIN_DELAY: 400,          // 400ms
        MAX_DELAY: 1000,         // 1000ms
        LEAVE_MIN_DELAY: 500,    // 500ms
        LEAVE_MAX_DELAY: 1500,   // 1500ms
        CHAT_MIN_DELAY: 500,     // 500ms
        CHAT_MAX_DELAY: 1200,    // 1200ms
        TYPE_SPEED: {
            MIN: 50,             // 50ms/字
            MAX: 150             // 150ms/字
        }
    };

    // 可自定义的筛选省份（页面文本需为这些全称）
    // 例如：['北京','河北','天津']，可自行增删
    const REGION_KEYWORDS = ["北京", "天津", "河北"]; // 用户可在此行自定义

    // 全称到短标映射，用于面板展示（不影响内部匹配）
    const REGION_SHORT_MAP = {
        "北京": "京",
        "天津": "津",
        "河北": "冀",
        "上海": "沪",
        "重庆": "渝",
        "内蒙古": "蒙",
        "黑龙江": "黑",
        "吉林": "吉",
        "辽宁": "辽",
        "山东": "鲁",
        "山西": "晋",
        "陕西": "陕",
        "甘肃": "甘",
        "青海": "青",
        "河南": "豫",
        "江苏": "苏",
        "浙江": "浙",
        "安徽": "皖",
        "江西": "赣",
        "福建": "闽",
        "广东": "粤",
        "广西": "桂",
        "海南": "琼",
        "四川": "川",
        "贵州": "黔",
        "云南": "滇",
        "西藏": "藏",
        "宁夏": "宁",
        "新疆": "新",
        "湖北": "鄂",
        "湖南": "湘",
        "河南": "豫"
    };

    const REGION_STORAGE_KEY = 'shushu_region_keywords';

    function loadRegionKeywords() {
        try {
            const stored = localStorage.getItem(REGION_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed) && parsed.length > 0) {
                    // 与默认列表合并，避免旧版本覆盖导致只剩定位省份
                    const merged = Array.from(new Set([ ...REGION_KEYWORDS, ...parsed ]));
                    return merged;
                }
            }
        } catch (e) {}
        return REGION_KEYWORDS.slice();
    }

    function saveRegionKeywords(regions) {
        try {
            localStorage.setItem(REGION_STORAGE_KEY, JSON.stringify(regions));
        } catch (e) {}
    }

    let CURRENT_REGION_KEYWORDS = loadRegionKeywords();

    function getRegionShortDisplay() {
        if (!isRegionFilterEnabled) return "不限";
        const shorts = CURRENT_REGION_KEYWORDS.map(name => REGION_SHORT_MAP[name] || name).join('/');
        return shorts || '不限';
    }

    function normalizeProvinceName(name) {
        if (!name) return '';
        let n = name.trim();
        const specialMap = {
            '内蒙古自治区': '内蒙古',
            '广西壮族自治区': '广西',
            '宁夏回族自治区': '宁夏',
            '新疆维吾尔自治区': '新疆',
            '西藏自治区': '西藏',
            '香港特别行政区': '香港',
            '澳门特别行政区': '澳门'
        };
        if (specialMap[n]) return specialMap[n];
        n = n.replace(/(省|市|自治区|特别行政区)$/g, '');
        return n;
    }

    async function setRegionFromLocation(lat, lon) {
        try {
            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&zoom=5&addressdetails=1`;
            const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
            const data = await resp.json();
            const addr = data && data.address ? data.address : {};
            const raw = addr.state || addr.county || addr.region || addr.province || '';
            const province = normalizeProvinceName(raw);
            if (province) {
                const merged = Array.from(new Set([ ...REGION_KEYWORDS, ...(CURRENT_REGION_KEYWORDS || []), province ]));
                CURRENT_REGION_KEYWORDS = merged;
                saveRegionKeywords(CURRENT_REGION_KEYWORDS);
                console.log('定位到省份并已加入筛选:', province, '当前筛选集:', CURRENT_REGION_KEYWORDS);
                return province;
            }
        } catch (e) {
            console.error('定位或反查失败:', e);
        }
        return null;
    }

    const GREETINGS = [
        "hi，宝宝~",
        "你好呀，宝宝",
        "hello，宝宝",
        "你好，宝宝",
        "嗨，宝宝",
        "hey，宝宝",
       ];

    const TIME_GREETINGS = [
        { start: 5, end: 11, greetings: ["早上好"] },
        { start: 11, end: 14, greetings: ["中午好"] },
        { start: 14, end: 18, greetings: ["下午好"] },
        { start: 18, end: 24, greetings: ["晚上好"] },
        { start: 0, end: 5, greetings: ["夜深了，聊会吧"] }
    ];

    let isLocked = false;
    let isScriptEnabled = true;
    let matchCount = 0;
    let startTime = Date.now();
    let isInLeaveProcess = false;
    let lastActionTime = Date.now();
    let hasGreeted = false;
    let lastSessionId = null;
    let hasSecondReplied = false;
    // 防重复问候：进行中标记、上次会话标识与时间戳节流
    let isGreetingInProgress = false;
    let lastGreetingSessionId = null;
    let lastGreetingAt = 0;
    let isRegionFilterEnabled = (function() {
        try {
            const saved = localStorage.getItem("shushu_region_filter_enabled");
            if (saved === null) return true; // 默认开启
            return saved === "true";
        } catch (e) {
            return true;
        }
    })();

    // 统计：发现女生次数 与 因地区筛选被跳过次数
    let statsFoundFemale = 0;
    let statsSkippedByRegion = 0;
    let lastCountedFemaleSessionId = null;
    let lastSkippedByRegionSessionId = null;
    let isProgrammaticLeaveClick = false;

    function canLeaveNow() {
        // 纯手动优先：始终拦截用户手点（仅程序白名单放行）
        return false;
    }

    function setupLeaveGuard() {
        try {
            const guardedSelectors = [
                'a.button-link.leave',
                'a.button-link.chat-control',
                'a.leave',
                '.chat-control',
                'span.chat-control',
                "a[class*='leave']",
                "a[class*='chat-control']"
            ].join(',');

            document.addEventListener('click', function(e) {
                const target = e.target;
                if (!target) return;
                const btn = target.closest(guardedSelectors);
                if (!btn) return;

                if (isProgrammaticLeaveClick) {
                    // 放行程序触发的点击
                    return;
                }

                if (!canLeaveNow()) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.warn('已拦截离开/重新开始点击，避免误退');
                }
            }, true);
        } catch (err) {
            console.error('leave guard 安装失败:', err);
        }
    }

    function getRandomDelay(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min) + Math.random() * 100;
    }

    function getRandomGreeting() {
        const hour = new Date().getHours();
        let timeGreetings = [];
        for (const tg of TIME_GREETINGS) {
            if (hour >= tg.start && hour < tg.end) {
                timeGreetings = tg.greetings;
                break;
            }
        }
        // 50%概率用时间问候，否则用原有问候
        if (timeGreetings.length && Math.random() < 0.5) {
            return timeGreetings[Math.floor(Math.random() * timeGreetings.length)];
        }
        return GREETINGS[Math.floor(Math.random() * GREETINGS.length)];
    }

    const SECOND_REPLIES = [
        "宝宝多大了",
        "宝宝喜欢被调吗？",
    ];

    function getRandomSecondReply() {
        return SECOND_REPLIES[Math.floor(Math.random() * SECOND_REPLIES.length)];
    }

    async function simulateTyping(msgInput, text) {
        msgInput.focus();
        const originalText = text;
        for(let i = 0; i < text.length; i++) {
            msgInput.value = text.substring(0, i + 1);
            msgInput.dispatchEvent(new Event('input'));
            await new Promise(r => setTimeout(r,
                getRandomDelay(CONFIG.TYPE_SPEED.MIN, CONFIG.TYPE_SPEED.MAX)));
        }
        return msgInput.value === originalText;
    }

    function findLeaveButton() {
        const selectors = [
            "a.button-link.leave",
            "a.button-link.chat-control",
            "a.leave",
            ".chat-control",
            "span.chat-control",
            "a[class*='leave']",
            "a[class*='chat-control']"
        ];

        for (const selector of selectors) {
            const button = document.querySelector(selector);
            if (button) return button;
        }
        return null;
    }

function hasNewSystemMessage() {
        try {
            // 优先检查最近的系统消息气泡，避免因全页残留文本误判
            const systemCandidates = Array.from(document.querySelectorAll('.message.system, .system, .chat-system, .system-message'));
            for (let i = systemCandidates.length - 1; i >= 0 && i >= systemCandidates.length - 3; i--) {
                const text = (systemCandidates[i] && systemCandidates[i].innerText) || '';
                if (text.includes("对方离开了")) return true;
            }

            // 其次尝试从聊天区域的最后一项判断
            const chatArea = document.querySelector('.messages, .chat, .chat-area');
            if (chatArea && chatArea.lastElementChild) {
                const last = chatArea.lastElementChild;
                const t = (last && last.innerText) || '';
                if (t.includes("对方离开了")) return true;
            }

            // 兜底：全页文本匹配（可能产生误判）
            const pageText = document.body ? document.body.innerText : '';
            return pageText.includes("对方离开了");
        } catch (error) {
            console.error("系统消息检查出错:", error);
            return false;
        }
}

    function hasLeaveModal() {
        return !!document.querySelector(".actions-modal");
    }

    async function handleLeaveModal() {
        const confirmButton = document.querySelector(".actions-modal-button-bold.color-danger");
        if (confirmButton) {
            await new Promise(r => setTimeout(r, getRandomDelay(200, 400)));
            confirmButton.click();
            await new Promise(r => setTimeout(r, CONFIG.LEAVE_MAX_DELAY));
        }
    }

    function createStatsDisplay() {
        const statsDiv = document.createElement('div');
        statsDiv.style.cssText = `
            position: fixed;
            top: 50px;
            left: 10px;
            background: linear-gradient(145deg, rgba(0,0,0,0.2), rgba(40,40,40,0.3));
            color: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 9999;
            font-family: 'Arial', sans-serif;
            box-shadow: 0 3px 10px rgba(0,0,0,.08);
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 150px;
            backdrop-filter: blur(2px);
            transition: all 0.3s ease;
            user-select: none;
            opacity: 0.85;
        `;

        const toggleButton = document.createElement('button');
        toggleButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: ${isScriptEnabled ? '#4CAF50' : '#f44336'};
            border: none;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.8;
        `;

        toggleButton.addEventListener('click', () => {
            isScriptEnabled = !isScriptEnabled;
            toggleButton.style.background = isScriptEnabled ? '#4CAF50' : '#f44336';
        });

        // 地区筛选开关
        const regionToggle = document.createElement('button');
        regionToggle.style.cssText = `
            position: absolute;
            top: 10px;
            left: 10px;
            background: ${isRegionFilterEnabled ? '#2196F3' : '#607D8B'};
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 1px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.9;
        `;
        regionToggle.textContent = isRegionFilterEnabled ? '京津冀:开' : '京津冀:关';
        regionToggle.addEventListener('click', () => {
            isRegionFilterEnabled = !isRegionFilterEnabled;
            localStorage.setItem('shushu_region_filter_enabled', String(isRegionFilterEnabled));
            regionToggle.style.background = isRegionFilterEnabled ? '#2196F3' : '#607D8B';
            regionToggle.textContent = isRegionFilterEnabled ? '京津冀:开' : '京津冀:关';
            // 立即刷新展示
            if (statsDiv._contentDiv) updateStatsDisplay(statsDiv);
        });

        // 定位按钮：自动设置本地省份为筛选
        const locateButton = document.createElement('button');
        locateButton.style.cssText = `
            position: absolute;
            top: 40px;
            left: 10px;
            background: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 1px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.9;
        `;
        locateButton.textContent = '定位:本地';
        locateButton.addEventListener('click', async () => {
            try {
                if (!navigator.geolocation) {
                    alert('此浏览器不支持定位');
                    return;
                }
                locateButton.disabled = true;
                locateButton.textContent = '定位中...';
                navigator.geolocation.getCurrentPosition(async (pos) => {
                    const { latitude, longitude } = pos.coords;
                    const province = await setRegionFromLocation(latitude, longitude);
                    if (province) {
                        isRegionFilterEnabled = true;
                        localStorage.setItem('shushu_region_filter_enabled', 'true');
                        regionToggle.style.background = '#2196F3';
                        regionToggle.textContent = '京津冀:开';
                        // 刷新显示，显示为 累加后的短标集
                        if (statsDiv._contentDiv) updateStatsDisplay(statsDiv);
                        alert('已将本地省份加入筛选：' + province + '（与当前列表累加）');
                    } else {
                        alert('未能识别省份');
                    }
                    locateButton.disabled = false;
                    locateButton.textContent = '定位:本地';
                }, (err) => {
                    alert('定位失败：' + err.message);
                    locateButton.disabled = false;
                    locateButton.textContent = '定位:本地';
                }, { enableHighAccuracy: true, timeout: 10000 });
            } catch (e) {
                alert('定位异常');
                locateButton.disabled = false;
                locateButton.textContent = '定位:本地';
            }
        });

        statsDiv.appendChild(toggleButton);
        statsDiv.appendChild(regionToggle);
        statsDiv.appendChild(locateButton);

        // 手动退出按钮（安全触发离开流程）
        const manualExitButton = document.createElement('button');
        manualExitButton.style.cssText = `
            position: absolute;
            top: 40px;
            left: 90px;
            background: #e53935;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 1px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.9;
        `;
        manualExitButton.textContent = '退出';
        manualExitButton.addEventListener('click', async () => {
            if (manualExitButton.disabled) return;
            manualExitButton.disabled = true;
            try {
                isInLeaveProcess = true;
                const leaveButton = findLeaveButton();
                if (leaveButton) {
                    isProgrammaticLeaveClick = true;
                    leaveButton.click();
                    isProgrammaticLeaveClick = false;
                    await new Promise(r => setTimeout(r, CONFIG.LEAVE_MIN_DELAY));
                }
                await handleLeaveModal();
                await startNewChat();
            } catch(e) {
                console.error('手动退出失败', e);
            } finally {
                isInLeaveProcess = false;
                manualExitButton.disabled = false;
            }
        });
        statsDiv.appendChild(manualExitButton);
        
        // 用于承载动态统计内容的容器，避免刷新时移除按钮
        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = `margin-top: 56px;`;
        statsDiv.appendChild(contentDiv);
        // 存储引用，供 updateStatsDisplay 使用
        statsDiv._contentDiv = contentDiv;
        document.body.appendChild(statsDiv);
        return statsDiv;
    }

    function updateStatsDisplay(statsDiv) {
        const runTime = Math.floor((Date.now() - startTime) / 60000);
        const hours = Math.floor(runTime / 60);
        const minutes = runTime % 60;
        const timeStr = hours > 0 ? `${hours}时${minutes}分` : `${minutes}分`;

        const target = statsDiv._contentDiv || statsDiv; // 兼容旧结构
        target.innerHTML = `
            <div style=\"margin-bottom: 6px; line-height: 1.2;\">
                <span style=\"display:inline-block;width:16px;text-align:center;font-size:14px;color:#2196F3;\">📍</span>
                筛选: ${getRegionShortDisplay()}
            </div>
            <div style=\"margin-bottom: 6px; font-size: 14px; color: rgba(255,255,255,0.85); line-height: 1.2;\">
                <span style=\"display:inline-block;width:16px;text-align:center;\">👩</span>
                女生: ${matchCount}，筛掉: ${statsSkippedByRegion}
            </div>
            <div style=\"font-size: 14px; color: rgba(255,255,255,0.8); line-height: 1.2;\">
                <span style=\"display:inline-block;width:16px;text-align:center;\">🕒</span>
                时间: ${timeStr}
            </div>
        `;
    }

    async function handlePartnerLeft() {
        if (isInLeaveProcess) return;

        console.log("检测到对方离开，准备重新开始");
        isLocked = false;
        isInLeaveProcess = true;

        try {
            await new Promise(r => setTimeout(r, 500));

            if (hasLeaveModal()) {
                await handleLeaveModal();
            }

            const leaveButton = findLeaveButton();
            if (leaveButton) {
                await new Promise(r => setTimeout(r, getRandomDelay(200, 400)));
                isProgrammaticLeaveClick = true;
                leaveButton.click();
                isProgrammaticLeaveClick = false;
                await new Promise(r => setTimeout(r, CONFIG.LEAVE_MIN_DELAY));
            }

            await startNewChat();

        } catch (error) {
            console.error("离开处理出错:", error);
        } finally {
            isLocked = false;
            isInLeaveProcess = false;
            console.log("重新开始完成");
        }
    }

    async function handleMaleMatch() {
        if (isInLeaveProcess) return;

        try {
            isInLeaveProcess = true;

            // 仅当是我们主动的离开流程中，才处理离开弹窗并重新开始
            if (hasLeaveModal()) {
                if (isInLeaveProcess) {
                    await handleLeaveModal();
                    await startNewChat();
                }
                return;
            }

            const leaveButton = findLeaveButton();
            if (leaveButton) {
                await new Promise(r => setTimeout(r, getRandomDelay(200, 400)));
                isProgrammaticLeaveClick = true;
                leaveButton.click();
                isProgrammaticLeaveClick = false;
                await new Promise(r => setTimeout(r, CONFIG.LEAVE_MIN_DELAY));
            }

            await handleLeaveModal();
            await startNewChat();

        } catch (error) {
            console.error("男生匹配处理出错:", error);
        } finally {
            isLocked = false;
            isInLeaveProcess = false;
        }
    }

    async function handleFemaleMatch() {
        if (isLocked || isInLeaveProcess) {
            console.log("已锁定或正在离开过程中");
            return;
        }

        try {
            if (hasNewSystemMessage()) {
                console.log("检测到对方离开消息");
                await handlePartnerLeft();
                return;
            }

            await new Promise(r => setTimeout(r, 500));

            // 地区筛选（可开关）
            const partnerInfo = document.querySelector("#partnerInfoText");
            // 仅在每个女生会话首次计数
            const currentSessionId = getCurrentSessionId();
            if (currentSessionId && currentSessionId !== lastCountedFemaleSessionId) {
                statsFoundFemale++;
                lastCountedFemaleSessionId = currentSessionId;
            }
            if (isRegionFilterEnabled) {
                const partnerText = partnerInfo ? partnerInfo.innerText : "";
                const isTargetRegion = CURRENT_REGION_KEYWORDS.some(keyword => partnerText.includes(keyword));
                if (!partnerInfo || !isTargetRegion) {
                    // 仅在每个女生会话首次被筛掉时计数
                    if (currentSessionId && currentSessionId !== lastSkippedByRegionSessionId) {
                        statsSkippedByRegion++;
                        lastSkippedByRegionSessionId = currentSessionId;
                    }
                    console.log("对方不是目标地区，跳过配对");
                    await handleMaleMatch(); // 按男生处理，离开当前配对
                    return;
                }
            }

            const msgInput = document.querySelector("#msgInput");
            const sendButton = document.querySelector("a.button-link.msg-send");
            // 获取当前会话唯一标识
            const sessionId = getCurrentSessionId();
            if (!sessionId || sessionId.trim() === "") {
                // 可选：console.log("等待sessionId加载...");
                return;
            }

            // 检查本地存储是否已问候
            const greetedSession = localStorage.getItem("shushu_greeted_session");
            if (greetedSession === sessionId) {
                hasGreeted = true;
            } else {
                hasGreeted = false;
            }

            if (msgInput && sendButton && !hasGreeted) {
                // 多重防抖：若已有自己消息、正在问候、或节流时间未到，则不问候
                const myMsgs = document.querySelectorAll('.message.right');
                if (myMsgs && myMsgs.length > 0) {
                    return;
                }
                if (isGreetingInProgress) {
                    return;
                }
                const nowTs = Date.now();
                if (lastGreetingSessionId === sessionId && nowTs - lastGreetingAt < 8000) {
                    return;
                }
                isLocked = true;
                isGreetingInProgress = true;

                const greeting = getRandomGreeting();
                const typingSuccess = await simulateTyping(msgInput, greeting);

                if (hasNewSystemMessage()) {
                    isLocked = false;
                    await handlePartnerLeft();
                    return;
                }

                if (typingSuccess) {
                    sendButton.click();
                    matchCount++;
                    lastActionTime = Date.now();
                    hasGreeted = true;
                    lastSessionId = sessionId;
                    lastGreetingSessionId = sessionId;
                    lastGreetingAt = Date.now();
                    localStorage.setItem("shushu_greeted_session", sessionId); // 记录已问候
                    console.log("消息已发送");
                }
            }
        } catch (error) {
            console.error("女生匹配处理出错:", error);
        } finally {
            // 重置问候进行中标记；仍通过已发消息与 hasGreeted 控制后续行为
            isGreetingInProgress = false;
            if (!document.querySelector(".message.right")) {
                isLocked = false;
            }
        }
    }

    async function startNewChat() {
        try {
            await new Promise(r => setTimeout(r, 500));

            const restartButton = document.querySelector("span.chat-control");
            if (restartButton && (restartButton.innerText === "重新开始" || restartButton.innerText.includes("开始"))) {
                console.log("点击重新开始按钮");
                await new Promise(r => setTimeout(r, getRandomDelay(200, 400)));
            isProgrammaticLeaveClick = true;
            restartButton.click();
            isProgrammaticLeaveClick = false;

                let retryCount = 0;
                const maxRetries = 3;

                while (retryCount < maxRetries) {
                    await new Promise(r => setTimeout(r, CONFIG.LEAVE_MIN_DELAY));

                    const secondCheck = document.querySelector("span.chat-control");
                    if (secondCheck && (secondCheck.innerText === "重新开始" || secondCheck.innerText.includes("开始"))) {
                        console.log("重试点击重新开始");
                        isProgrammaticLeaveClick = true;
                        secondCheck.click();
                        isProgrammaticLeaveClick = false;
                    } else {
                        break;
                    }
                    retryCount++;
                }
            }
            isLocked = false;
            hasGreeted = false;
            lastSessionId = null;
            localStorage.removeItem("shushu_greeted_session");
            hasSecondReplied = false;
        } catch (error) {
            console.error("重新开始出错:", error);
            isLocked = false;
        }
    }

    function getCurrentSessionId() {
        const partnerInfo = document.querySelector("#partnerInfoText");
        if (partnerInfo) {
            return partnerInfo.innerText.trim();
        }
        return null;
    }

    async function mainLoop() {
        if (!isScriptEnabled) return;

        try {
            if (Date.now() - lastActionTime < CONFIG.CHECK_INTERVAL) return;

            if (hasLeaveModal()) {
                await handleLeaveModal();
                await startNewChat();
                return;
            }

            // 纯手动优先：检测到对方离开也不自动处理，交由面板“退出”手动触发

            if (isLocked) {
                return;
            }

            const partnerInfo = document.querySelector("#partnerInfoText");
            const partnerGender = partnerInfo ? partnerInfo.innerText : null;

            // 如果元素未加载或内容为空，延迟重试，不做任何操作
            if (!partnerGender || partnerGender.trim() === "") {
                // 可选：console.log("等待partnerInfoText加载...");
                return;
            }

            if (partnerGender.includes("男生")) {
                // 男生：自动离开
                await handleMaleMatch();
            } else if (partnerGender.includes("女生")) {
                // 女生：不自动离开、不自动重连，改为纯手动（面板“退出”）
                await handleFemaleMatch();
                // 检查是否需要自动二次回复
                await trySecondReply();
            }

        } catch (error) {
            console.error("主循环出错:", error);
            isLocked = false;
            isInLeaveProcess = false;
        }
    }

    async function trySecondReply() {
        if (hasSecondReplied) return;
        // 检查是否有对方的消息（假设左侧消息 class 为 .message.left）
        const leftMsgs = document.querySelectorAll('.message.left');
        // 只在有对方消息且自己还没二次回复时触发
        if (leftMsgs.length > 0) {
            // 检查自己是否已经发过第二句（防止多次触发）
            const rightMsgs = document.querySelectorAll('.message.right');
            if (rightMsgs.length < 2) {
                const msgInput = document.querySelector("#msgInput");
                const sendButton = document.querySelector("a.button-link.msg-send");
                if (msgInput && sendButton) {
                    const reply = getRandomSecondReply();
                    // 如果输入框内容已经是要发的内容，直接返回
                    if (msgInput.value === reply) return;
                    hasSecondReplied = true; // 提前设置，防止并发
                    await simulateTyping(msgInput, reply);
                    sendButton.click();
                    // 可选：console.log("已自动二次回复");
                }
            }
        }
    }

    function init() {
        const statsDiv = createStatsDisplay();

        // 装载离开保护
        setupLeaveGuard();

        const runMainLoop = () => {
            mainLoop();
            updateStatsDisplay(statsDiv);
            setTimeout(runMainLoop, CONFIG.CHECK_INTERVAL + Math.random() * 200);
        };

        setTimeout(runMainLoop, getRandomDelay(1000, 1500));
    }

    setTimeout(init, getRandomDelay(1000, 1500));
})();
